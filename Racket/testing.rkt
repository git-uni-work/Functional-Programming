#lang racket
(require compatibility/defmacro)

( define ( atom? x )
   ( and ( not ( null? x ) )
         ( not ( pair? x ) )
   )
)
;======================================================================================================
;======================================================================================================
(define ( add x y ) ( + x y ))
;======================================================================================================
;======================================================================================================
(define ( add2.0 x [ y 10 ] [ z 1 ] )
  ( + x y z )
)
;======================================================================================================
;======================================================================================================
(define ( add3.0 x . others )
  ( apply + x others )
) 
;======================================================================================================
;======================================================================================================
( define ( iseven n )
   (match ( remainder n 2 )
     [ 0 #t ]
     [ _ #f ]
   )
)
;======================================================================================================
;======================================================================================================
(define l '(1 2 3 4 5 6))
;======================================================================================================
;======================================================================================================
(define (sumeven x)
  ( if ( null? x )
    0
    ( if ( iseven (first x) )
         ( + (first x) (sumeven (rest x)) )
         ( sumeven (rest x) )
    )
  )
)
;======================================================================================================
;======================================================================================================
(define (sumodd x)
  ( if ( null? x )
       0
       ( if ( iseven (first x) )
            ( sumodd (rest x) )
            ( + (first x) (sumodd (rest x) ) )
       )
  )
)  
;======================================================================================================
;======================================================================================================
(define ( lenf x )
  ( if ( null? x )
       0
       ( if ( atom? (first x) )
            ( + 1 ( lenf ( rest x ) ) )
            ( + (sublenf ( lenf (rest x) )) (lenf ( rest x )) )
        )
   )
)
(define ( sublenf x )
  ( if ( = x 0 )
       1
       x
  )
)
;======================================================================================================
;======================================================================================================
(define (filtereven x)
  ( if ( null? x )
       '() 
       (if (iseven (first x))
           (append (list ( first x )) (filtereven (rest x)) )
           ( filtereven (rest x))
       )
  )
)
;======================================================================================================
;======================================================================================================
(define (filterodd x)
  ( if ( null? x )
       '() 
       (if (iseven (first x))
           ( filterodd (rest x))
           (append (list ( first x )) (filterodd (rest x)) )
       )
  )
)
;======================================================================================================
;======================================================================================================
(define (square n) ( expt n 2 ) )

(define (sqrlist x)
  (if (null? x)
      '()
      ( append (list (square (first x) )) (sqrlist (rest x) ) )
  )
)
;======================================================================================================
;======================================================================================================
(define (1st x i)
  (if ( > i 0 )
      ( cons ( first x ) ( 1st (rest x) (- i 1) ) )
      '()
  )
)

(define (2nd x i)
  (if ( > i 0 )
      ( 2nd (rest x) (- i 1) )
       x
  )
)

(define (split x)
  (list ( 1st x (/(lenf x)2) ) ( 2nd x (/(lenf x)2) ) )
)

;======================================================================================================
;======================================================================================================
(define ( factorial n )
  ( if ( or ( = n 1 ) ( = n 0 ) )
             1 
            ( * n (factorial( - n 1)) )
  )
)
;======================================================================================================
;======================================================================================================
(define ( tailfactorial n [acc 1] )
  ( if ( or ( = n 1 ) ( = n 0 ) )
            acc 
            ( tailfactorial( - n 1) (* n acc) )
  )
)
;======================================================================================================
;======================================================================================================
(define (moimap func x)
  (if (null? x)
      null
      ( cons (func (first x)) (moimap func (rest x)) )
  )
)
;======================================================================================================
;======================================================================================================
(define (moifilter func x)
  (if (null? x)
      null
      (if (func (first x))
          ( cons (first x) (moifilter func (rest x)) )
          ( moifilter func (rest x) )
      )
  )
)
;======================================================================================================
;======================================================================================================
(define (keep n x)
  (if (or ( > n (lenf x)) ( = n (lenf x)) ) 
      x
      (if ( = n 0 )
          null
          (cons (car x) (keep (- n 1) (rest x)) )
       )
  )
)  
;======================================================================================================
;======================================================================================================
(define (drop n x)
  (if (or ( > n (lenf x)) ( = n (lenf x)) ) 
      null
      (if (not( = n 0 ))
          (drop ( - n 1 ) (rest x))
          (cons (first x) (rest x))
      )
  )
)
;======================================================================================================
;======================================================================================================
(define (moiappend x lst)
  ( if (null? lst)
       ( cons x null )
       ( cons (first lst) (moiappend x (rest lst)) )
  )
)
;======================================================================================================
;======================================================================================================
(define (concat x1 x2)
  (if (and (null? x1) (null? x2))
      '()
      ( if (null? x1)
           x2
           (if (null? x2)
               x1
               (cons (first x1) (concat (rest x1) x2))
           )
       )
  )
)
;======================================================================================================
;======================================================================================================
(define (contain x e)
  (if (null? x)
      #f
      (if ( = e (first x) )
          #t
          ( contain ( rest x ) e )
      )
  )
)

(define (containpattern oglst pattern)
  (if (null? pattern)
      #t
      (if ( equal? (contain oglst (first pattern)) #f )
          #f
          (containpattern oglst (rest pattern))
      )
  )
)
;======================================================================================================
;======================================================================================================
(define (lastelement x)
  (if (null? (rest x))
      (first x)
      (lastelement (rest x))
  )
)
;======================================================================================================
;======================================================================================================
(define (rmvelement e x )
  (if (null? e)
      x
      (if (null? (rest x))
          (rest x)
          (if (null? (first x))
              null
              (if (equal? (first x) e )
                  (rmvelement e (rest x))
                  (cons (first x) (rmvelement e (rest x)))
              )
          )
      )
  )
)
;======================================================================================================
;======================================================================================================
(define (rangesum x min max)
  (cond
    ((null? x) 0 )
    
    ( (and ( >= (car x) min ) ( <= (car x) max ) )
      ( + (car x) (rangesum (rest x) min max ) ) )
    
    ( true (rangesum (rest x) min max) )
  )
)
;======================================================================================================
;======================================================================================================
(define (moislice x min max)
  (cond
    ((null? x) '() )
    
    ( (and ( > (car x) min ) ( <= (car x) max ) )
      ( cons (car x) (moislice (rest x) min max ) ) )
    
    ( true (moislice (rest x) min max) )
  )
)
;======================================================================================================
;======================================================================================================
(define (addifodd no x)
  (map ( lambda (elem) (if (iseven elem) elem (+ elem no) ) ) x )
)

(define (addifeven no x)
  (map ( lambda (elem) (if (iseven elem) (+ elem no) elem ) ) x )
)
;======================================================================================================    
;======================================================================================================

(define (filteroutless x no)
  (if (null? x)
      '()
      (if (or ( > (car x) no ) ( = (car x) no ) )
          (cons (car x) (filteroutless (cdr x) no))
          (filteroutless (cdr x) no)
       )
   )
)
;======================================================================================================    
;======================================================================================================
(define (multi a b) (* a b) )

(define (multiply x1 x2)
  ( if (and (null? x1) (null? x2) )
            '()
            (if (null? x1)
                x2
                (if (null? x2)
                    x1
                    (if ( and (atom? (car x1)) (atom? (car x2) ) ) 
                        ( cons (multi (car x1) (car x2)) (multiply (cdr x1) (cdr x2)) )
                        (if (not (atom? (car x1)) )
                            ( cons (multi (1) (car x2)) (multiply (cdr x1) (cdr x2)) )
                            (cons (multi (car x1) (1)) (multiply (cdr x1) (cdr x2)) )
                        )
                    )
                )
            )
   )
)
;======================================================================================================    
;======================================================================================================
(define (moimerge x1 x2)
  ( if (and (null? x1) (null? x2) )
            '()
            (if (null? x1)
                x2
                (if (null? x2)
                    x1
                    (if ( and (atom? (car x1)) (atom? (car x2) ) )
                        (if ( < (car x1) (car x2) )
                            (cons (cons (car x1) (car x2)) (moimerge (cdr x1) (cdr x2)))
                            (cons (cons (car x2) (car x1)) (moimerge (cdr x1) (cdr x2)))
                        )
                        (cons '((car x1) (car x2)) (moimerge (cdr x1) (cdr x2)))
                    )
                )
            )
  )
)

;======================================================================================================    
;======================================================================================================
(define (BSTfind tree e)
  (if (null? tree)
      false
      (if (equal? e (car tree))
          true
          (if (< e (car tree))
              (BSTfind (cadr tree) e)
              (BSTfind (caddr tree) e)
          )
       )
  )
)
;======================================================================================================    
;======================================================================================================
(define (BSTadd tree e)
  (if (null? tree)
      (list e null null)
      (if (equal? e (car tree))
          tree
          (if (< e (car tree))
              (list (car tree) (BSTadd (cadr tree) e) (caddr tree))
              (list (car tree) (cadr tree) (BSTadd (caddr tree) e))
           )
       )
   )
)
;======================================================================================================    
;======================================================================================================
(define (BSTcount tree e)
  (if (null? tree)
      0
      (if (equal? e (car tree))
          (cadr tree)
          (if ( < e (car tree))
              (BSTcount (caddr tree) e)
              (BSTcount (cadddr tree) e)
           )
       )
   )
)
;======================================================================================================    
;======================================================================================================
(define (swap x y)
  (let ([tmp x])
    (set! x y)
    (set! y tmp)
  )
  (write x)
  (write y)
)
(define-syntax-rule (x y) (swap x y))
;======================================================================================================
;======================================================================================================  
(define (2-vals x y)
  (values (+ x y) (* x y))
)
(define-syntax-rule (sum product) (2-vals x y))
;======================================================================================================
;======================================================================================================
(define (1element x)
  (if (null? x)
      false
      (if (equal? (cdr x) '())
          true
          false
      )
  )
)
(define-syntax-rule (is-singleton? x) (1element x))
;======================================================================================================
;======================================================================================================
(define (range start end x)
  ( if (equal? start end)
       (cons end null)
       (if ( > start end )
           null
           (cons start (range (+ start x) end x))
       )
  )
)
(define-macro (from start to end by x) `(range,start,end,x))
;======================================================================================================
;======================================================================================================
(define (sum-next x)
  (if (null? x)
      null
      (if (null? (cdr x))
          (cons (car x) null)
          (cons (+(car x)(cadr x)) (sum-next (cddr x)))
      )
  )
)
;======================================================================================================
;======================================================================================================
(define (moiif condition then else)
  (if condition
      then
      else
  )
)
(define-macro (? condition then : else) `(moiif,condition,then,else))
;======================================================================================================
;======================================================================================================
(define ( commondivisors a b [x 1] )
  (if (or ( < a x) (< b x))
      null
      (if (and(= (remainder a x) 0) (= (remainder b x) 0))
          (cons x (commondivisors a b (+ x 1)))
          (commondivisors a b (+ x 1))
      )
  )
)
;======================================================================================================
;======================================================================================================
(define (intersect x y)
  (if (or (null? x) (null? y))
      null
      (if (=(car x) (car y))
          (cons (car x) (intersect (cdr x) (cdr y)))
          (intersect (cdr x) y)
      )
  )
)



             
           
    
          






